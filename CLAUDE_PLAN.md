# CLAUDE_PLAN.md

> **Historical document.** This is the original implementation plan generated by Claude Code at
> project inception. The codebase was built from a bare Kotlin JVM skeleton. Sections marked
> ⚠️ **Deviated** describe where the final implementation differed from this plan and why.

---

## Context

The project started as a newly initialized Kotlin JVM skeleton (`Main.kt` only, no dependencies
beyond `kotlin("test")`). The goal: implement a full-featured Windows 11 desktop
scanner → searchable PDF application per `docs/SystemRequirements.md`.

The app must:
- Enumerate and connect to WIA-compatible scanners (e.g. Brother)
- Acquire images with configurable settings (duplex, color mode, DPI, paper size)
- Optionally run Tesseract OCR in the background
- Produce a PDF/A-1b file with embedded images, invisible searchable text, and custom XMP metadata

---

## Technology Decisions

| Concern | Choice | Rationale |
|---|---|---|
| UI | Compose for Desktop 1.8.2 | Idiomatic Kotlin, declarative state model, native Windows distribution via jpackage |
| PDF | Apache PDFBox 3.0.6 | Apache License 2.0 (vs. iText AGPL); full PDF/A-1b support including ICC OutputIntent and xmpbox |
| OCR | Tess4J 5.18.0 | JNA wrapper for Tesseract; Apache License; bundles Windows DLLs; supports LSTM engine |
| Scanner | WIA 2.0 via JNA 5.18.1 | WIA is 64-bit COM (TWAIN is 32-bit only); Brother scanners ship WIA drivers on Win 11; jna-platform provides COM base classes |
| Concurrency | Kotlinx Coroutines 1.10.2 | `Dispatchers.Default` for CPU-bound OCR/PDF; `Dispatchers.IO` for scanner I/O; cooperative cancellation via `ensureActive()` |

> **Critical gotcha:** Gradle must be upgraded from 8.0 → 8.12 — the `org.jetbrains.compose` 1.8.x
> plugin requires Gradle ≥ 8.6.

---

## Planned Package Structure

```
src/main/kotlin/com/jimandreas/
├── Main.kt                          -- singleWindowApplication() entry point
├── ui/
│   ├── App.kt                       -- root @Composable, holds AppState
│   ├── PresetConfigDialog.kt        -- "Configure Presets" modal
│   ├── ScanProgressDialog.kt        -- progress + cancel dialog
│   └── components/
│       ├── ScannerDropdown.kt
│       ├── SettingsDropdowns.kt     -- Sides/ColorMode/Resolution/PaperSize
│       ├── QualitySlider.kt         -- "Small Size ↔ High Quality" slider
│       └── OcrCheckbox.kt           -- OCR checkbox + language selector
├── state/
│   ├── AppState.kt                  -- mutableStateOf fields; suspend fun scanAndProcess()
│   ├── ScanSettings.kt              -- data class: sides, colorMode, dpi, paperSize, quality
│   ├── OcrSettings.kt               -- data class: enabled, language
│   └── PdfMetadata.kt               -- data class: author, title, keywords
├── scanner/
│   ├── ScannerDevice.kt             -- data class: id, displayName, connectionType
│   ├── ScannerRepository.kt         -- interface
│   ├── WiaScannerRepository.kt      -- WIA COM implementation (dedicated STA thread)
│   ├── WiaDevMgr2.kt                -- JNA vtable binding: IWiaDevMgr2
│   ├── WiaEnumDevInfo.kt            -- JNA vtable binding: IEnumWIA_DEV_INFO
│   ├── WiaPropertyStorage.kt        -- JNA vtable binding: IWiaPropertyStorage
│   ├── WiaConstants.kt              -- CLSIDs, IIDs, WIA property ID constants
│   └── ScannerException.kt          -- sealed class: DeviceNotFound, PaperJam, AcquisitionFailed
├── ocr/
│   ├── OcrEngine.kt                 -- interface: suspend fun recognizePages(...)
│   └── TesseractOcrEngine.kt        -- Tess4J implementation with cancellation support
├── pdf/
│   ├── PdfBuilder.kt                -- assembles PDF/A-1b: images + OCR text + ICC + metadata
│   └── PdfMetadataWriter.kt         -- xmpbox XMP + PDDocumentInformation
└── util/
    ├── ImageProcessor.kt            -- JPEG compression, grayscale/B&W conversion
    └── CoroutineDispatchers.kt      -- injectable dispatchers for testability

src/main/resources/
└── srgb.icc                         -- sRGB ICC profile for PDF/A-1b OutputIntent

appResources/windows-x64/
└── tessdata/
    ├── eng.traineddata              -- Tesseract LSTM English model
    └── osd.traineddata
```

> ⚠️ **Deviated — additional files created:**
> - `scanner/ScannedPage.kt` — data class `ScannedPage(image: BufferedImage, dpi: Int)`;
>   carries actual DPI read from WIA-saved file metadata alongside the image through the pipeline
> - `ocr/OcrWord.kt` — data class carrying recognized word text and its bounding box;
>   enables per-word positioned text overlay in the PDF

---

## Files to Modify / Create

### 1. `gradle/wrapper/gradle-wrapper.properties`

```properties
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-bin.zip
```

### 2. `settings.gradle.kts`

Add a `pluginManagement` block with `gradlePluginPortal()`, `mavenCentral()`, and `google()` repositories.

### 3. `build.gradle.kts` — complete replacement

```kotlin
import org.jetbrains.compose.desktop.application.dsl.TargetFormat

plugins {
    kotlin("jvm") version "2.2.21"
    id("org.jetbrains.compose") version "1.8.2"
    id("org.jetbrains.kotlin.plugin.compose") version "2.2.21"
}

group = "com.jimandreas"
version = "1.0-SNAPSHOT"

repositories {
    mavenCentral()
    google()
}

dependencies {
    implementation(compose.desktop.currentOs)
    implementation(compose.material3)
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.10.2")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-swing:1.10.2")
    implementation("org.apache.pdfbox:pdfbox:3.0.6")
    implementation("org.apache.pdfbox:xmpbox:3.0.6")
    implementation("org.apache.pdfbox:preflight:3.0.6")
    implementation("javax.xml.bind:jaxb-api:2.3.1")
    implementation("net.sourceforge.tess4j:tess4j:5.18.0")
    implementation("net.java.dev.jna:jna:5.18.1")
    implementation("net.java.dev.jna:jna-platform:5.18.1")
    testImplementation(kotlin("test"))
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.10.2")
}

kotlin { jvmToolchain(17) }
tasks.test { useJUnitPlatform() }

compose.desktop {
    application {
        mainClass = "com.jimandreas.MainKt"
        nativeDistributions {
            targetFormats(TargetFormat.Msi, TargetFormat.Exe)
            packageName = "ScanWithOCRtoPDF"
            packageVersion = "1.0.0"
            appResourcesRootDir.set(project.layout.projectDirectory.dir("appResources"))
        }
    }
}

tasks.withType<JavaExec> {
    jvmArgs("--add-opens", "java.base/java.lang=ALL-UNNAMED",
            "--add-opens", "java.desktop/java.awt.image=ALL-UNNAMED")
}
```

> ⚠️ **Deviated — additions made post-implementation:**
> - `testRuntimeOnly("org.slf4j:slf4j-simple:2.0.17")` added to suppress SLF4J no-provider warning in tests
> - `tasks.test` also received the same `--add-opens` `jvmArgs` as `JavaExec` (Tess4J and PDFBox
>   use reflection on AWT internals at test time)

### 4. All new source files

Created per the package structure above. `Main.kt` is replaced (not a new file).

---

## Implementation Phases

### Phase 1 — Build Infrastructure ✅

1. Update Gradle wrapper to 8.12
2. Update `settings.gradle.kts` with `pluginManagement`
3. Replace `build.gradle.kts`
4. Run `./gradlew dependencies` to verify artifact resolution
5. Replace `Main.kt` with a minimal `singleWindowApplication { }` that opens a blank window
6. Add `srgb.icc` to `src/main/resources/`

### Phase 2 — WIA Scanner Integration ✅

1. Define `WiaConstants.kt` — CLSIDs, IIDs, and WIA property IDs as JNA GUID instances
2. Implement JNA COM vtable bindings: `WiaDevMgr2`, `WiaEnumDevInfo`, `WiaPropertyStorage`
3. Implement `WiaScannerRepository`:
   - Dedicated single-thread executor for COM STA (`CoInitializeEx` + `COINIT_APARTMENTTHREADED`)
   - `enumerateDevices()` → `CoCreateInstance(CLSID_WiaDevMgr2)` → enumerate → read `WIA_DIP_DEV_NAME`
   - `acquireImages(device, settings)` → `IWiaDevMgr2::GetImageDlg` → `ImageIO.read(file)`
4. Map WIA HRESULTs to `ScannerException` sealed subclasses

> ⚠️ **Deviated — acquisition method changed:**
> The plan called for `IWiaDataTransfer::idtGetData` for image acquisition. The actual
> implementation uses `IWiaDevMgr2::GetImageDlg` (vtable index 10 in WIA 2.0 — index 7 is
> `RegisterEventCallbackInterface`, not `GetImageDlg` as in WIA 1.0). This approach saves files to
> a temp folder and returns file paths; `ImageIO.read(file)` then loads the `BufferedImage`. The
> actual DPI is read back from the file's `javax_imageio_1.0` metadata (since the WIA dialog
> controls DPI independently of the app's `scanSettings.dpi`) and carried in
> `ScannedPage(image, dpi)`.

### Phase 3 — UI "Configure Presets" Modal ✅

1. Define `ScanSettings`, `OcrSettings`, `PdfMetadata` data classes with defaults
2. Implement `AppState` with `mutableStateOf` fields
3. Build `PresetConfigDialog` composable:
   - Scanner `ExposedDropdownMenuBox` + "Options" button
   - Input card: Sides / Color Mode / Resolution / Paper Size dropdowns
   - Optimization Slider (0–100, mapped to JPEG quality 0.3–0.95)
   - OCR Checkbox + animated language dropdown
   - Metadata fields: Author, Title, Keywords
   - "Scan" and "Cancel" buttons
4. Build `ScanProgressDialog` showing phase and page count

> ⚠️ **Deviated — `AppState` coroutine API renamed:**
> The plan called the main coroutine `scanAndProcess()`. The final API is split into
> `startScan()`, `finalizePdf()`, and `cancelScan()` for cleaner responsibility boundaries.

### Phase 4 — OCR Background Threading ✅

1. Implement `TesseractOcrEngine.recognizePage()` using `withContext(Dispatchers.Default)` with `ensureActive()` per page
2. Implement `AppState.startScan()` coroutine orchestrating:
   - Scanner I/O on `Dispatchers.IO` (WIA STA executor)
   - Image compression on `Dispatchers.Default`
   - OCR on `Dispatchers.Default` (conditional)
   - PDF build on `Dispatchers.Default`
   - Progress updates back on `Dispatchers.Main`
3. "Cancel" button calls `scanJob.cancel()`; `CancellationException` triggers temp-file cleanup
4. `ScannerException` variants shown as `AlertDialog` with user-readable messages

> ⚠️ **Deviated — OCR method changed from `doOCR()` to `getWords(RIL_WORD)`:**
> The plan assumed Tesseract's `doOCR()` returning a text block. The final implementation uses
> `tess.getWords(image, RIL_WORD)` to obtain per-word bounding boxes, enabling accurate positioned
> overlay in the PDF. Also: `user_defined_dpi` must be set on the `Tesseract` instance because
> `BufferedImage` carries no DPI metadata and Tesseract defaults to 70 DPI otherwise.

### Phase 5 — PDF/A Generation ✅

1. `PdfBuilder.build()`:
   - Add PDF/A-1b `OutputIntent` with bundled `srgb.icc` via `PDICCBased`
   - Per page: embed JPEG via `PDImageXObject.createFromByteArray()`, draw to page via `PDPageContentStream`
   - If OCR text present: append invisible text layer (rendering mode 3) using embedded NotoSans TTF, positioned by per-word bounding boxes
   - Delegate metadata to `PdfMetadataWriter`
2. `PdfMetadataWriter.write()`:
   - xmpbox `XMPMetadata` with DublinCore (title, creator, subjects) + XMPBasic + PDFA Identification (part=1, conformance=B)
   - Also set `PDDocumentInformation` for backward-compatible readers

> ⚠️ **Deviated — font type changed:**
> The plan specified `PDType0Font` (CIDFont with Identity-H encoding). The final implementation
> uses `PDTrueTypeFont` with `WinAnsiEncoding`. `PDType0Font` writes GIDs into the PDF stream;
> digit GIDs in NotoSans fall in the Hangul Jamo Unicode block, causing digits to copy-paste as
> Korean characters. `PDTrueTypeFont` + `WinAnsiEncoding` writes familiar ASCII/Latin-1 code
> points directly, solving the corruption. Word text is filtered to `c.code in 0x20..0xFF` before
> `showText`.
>
> ⚠️ **Deviated — JPEG quality default raised:**
> The plan implied the default slider quality. The default was raised from 0.75 to 0.90 because
> 75% JPEG quality introduces visible DCT blockiness on high-contrast document text.

### Phase 6 — Batch Scanning ✅

1. After first page acquisition, show `AlertDialog`: "Scan More Pages" | "Done"
2. "Scan More Pages" re-calls `acquireImages()` and appends to the accumulated list
3. ADF scanners return multiple pages per call naturally; flatbed uses this dialog loop

### Phase 7 — Distribution Packaging ✅

1. Download `eng.traineddata` + `osd.traineddata` into `appResources/windows-x64/tessdata/`
2. Run `./gradlew packageMsi` or `./gradlew packageExe`
3. Bundled output includes JRE 17, all JARs, and tessdata folder

---

## Key Design Notes

- **COM STA requirement:** All WIA COM calls must be made on the single dedicated executor thread
  that called `CoInitializeEx(COINIT_APARTMENTTHREADED)`. Never call WIA from `Dispatchers.IO`
  (thread pool → MTA conflict).
- **Tess4J DLL extraction:** Tess4J unpacks native DLLs to a temp directory on first use (~2s).
  Set `System.setProperty("jna.library.path", resourcesDir)` before first `Tesseract`
  instantiation.
- **Kotlin plugin version alignment:** `kotlin("jvm")` and `org.jetbrains.kotlin.plugin.compose`
  must both be `2.2.21`.
- **PDF/A invisible text font:** Use `PDTrueTypeFont.load(document, notoSansTtfStream,
  WinAnsiEncoding.INSTANCE)` — `PDType0Font` (Identity-H) corrupts digit copy-paste due to
  GID/Unicode mismatch in NotoSans.

---

## Verification Checklist

1. **Build:** `./gradlew build` completes with no errors after Phase 1
2. **Window:** `./gradlew run` shows a blank Compose window
3. **Scanner enumeration:** With Brother scanner connected, device appears in dropdown
4. **Scan acquisition:** Clicking "Scan" opens the WIA dialog and produces scanned images
5. **OCR:** A test image run through `TesseractOcrEngine` returns expected text with correct bounding boxes
6. **PDF output:** Open generated PDF in Adobe Acrobat and verify:
   - Ctrl+F text search finds OCR'd words
   - Search highlights appear at the correct position over the scanned text
   - Digits and punctuation copy-paste correctly
   - File → Properties → Description shows Author/Title/Keywords
   - Preflight → PDF/A-1b reports no violations
7. **Cancellation:** Click "Cancel" mid-OCR; confirm no orphaned temp files and UI returns to ready state
8. **Packaging:** `./gradlew packageMsi` produces an installable MSI; install on a clean Windows 11 VM and verify all features work without a JDK installed
